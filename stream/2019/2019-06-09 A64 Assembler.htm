<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content=""/>
    <meta name="author" content="Namdak Tonpa"/>
    <title>2019-06-09</title>
    <link rel="stylesheet" href="../../blank.css"/>
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>TOP</a>
    <a href='#'>2019-06-09</a>
</nav>
<main>
    <section>
        <h3>A64 ASM</h3>

        <p>Сегодня мы напишем минимальный ассемблер для компиляции объектного кода,
           который получается на выходе clang от компиляции C-шной программы Hello World.</p>

        <p>Возможно первый формальный гипервизор который будет написан на Эрланге или на подобии Эрланга
           будет написан с использованием этого ассеблера. Как вы знаете LLVM совершенно не поддаётся
           нужнам верификации так как его спецификация очень громоздкая. Гланая мотивация этой работы
           снизить количественные рамки формализации ассемблирования. Благодаря встроенному синтаксису Эрланга
           для работы с битовыми строками задача конструирования 32-битной инструкции из набора битовых
           строк перемнной длинны не составляет труда и может быть легко формализирована в MLTT языках.</p>

        <p>Таким образом мы убегаем от пробелемы верифакации компилятора и переносим всю работу
           по оптимизации и дизайну на авторов библиотеки, которые будут строить свои функции используя
           компиляцию в формальный ассемблер. Такой подход в использовании MLTT язка как макросистемы
           для компилировать один из перспективных методов формальной верификации, который в отличие от VST
           и других сложных путей верификации, позволяет насладится минималистичностью и по дороге убрать
           все ненужные слои абстрации включая MIR и LLVM и использовать векторную компиляция в NEON как
           это формально делает система Spiral, только намного лайтовее.</p>

        <p>Начнём с простого, с Hello World:</p>
        <figure><code>
 #include &lt;stdio.h&gt;
 int main( ) {
     printf("Hello, world!\n");
 }
        </code></figure>
        <p>Откомпилируем это под ARM64 на вашем Macbook и посмотрим, что получилось:</p>
        <figure><code>
 $ clang -isysroot $(xcrun --sdk iphoneos --show-sdk-path) \
         -arch arm64 asm.c -o asm.o
        </code></figure>
        <p>Ассемблеровский текст результата (без меток, адресов и хекса) сохраняем в фафл asm.s.</p>
        <figure><code>
 $ objdump -disassemble asm.o

 _main:
 100007f40:  ff 83 00 d1     sub sp, sp, #32
 100007f44:  fd 7b 01 a9     stp x29, x30, [sp, #16]
 100007f48:  fd 43 00 91     add x29, sp, #16
 100007f4c:  08 00 00 90     adrp    x8, #0
 100007f50:  08 a1 3e 91     add x8, x8, #4008
 100007f54:  00 00 80 52     mov w0, #0
 100007f58:  a0 c3 1f b8     stur    w0, [x29, #-4]
 100007f5c:  e0 03 08 aa     mov x0, x8
 100007f60:  06 00 00 94     bl  #24 &lt;dyld_stub_binder+0x100007f78&gt;
 100007f64:  a9 c3 5f b8     ldur    w9, [x29, #-4]
 100007f68:  e0 03 09 aa     mov x0, x9
 100007f6c:  fd 7b 41 a9     ldp x29, x30, [sp, #16]
 100007f70:  ff 83 00 91     add sp, sp, #32
 100007f74:  c0 03 5f d6     ret
        </code></figure>
        <p>Хотим в распарсаном виде иметь такой стрим (в основном всё из атомов,
           так как они меньше всего загрязняют эрланг синтаксис):</p>
        <figure><code>
 [{sub,sp,sp,32},
  {stp,x29,x30,[sp,16]},
  {add,x29,sp,16},
  {adrp,x8,0}
  {add,x8,x8,4008},
  {mov,w0,0},
  {stur,w0,[x29,-4]},
  {mov,x0,x8}
  {bl,[24,'0x100007f78']},
  {ldur,w9,[x29,-4]},
  {mov,x0,x9},
  {ldp,x29,x30,[sp,16]},
  {add,sp,sp,32}
  {ret}]
        </code></figure>
         <p>Попробуем написать парсер этого асм стрима:</p>
        <figure><code>
 atom("#"++X) -> list_to_integer(X);
 atom(X)      -> list_to_atom(X).

 last(X,Y,A)  ->
   case lists:reverse(X) of
      "]"++Z -> [lists:reverse([atom(lists:reverse(Z))|Y])|A];
           _ -> {[atom(X)|Y],A} end.

 code(Bin) ->
   [ lists:reverse(
     lists:foldl(
       fun([$[|X],A) -> last(X,[],A);
          (X,{Y,A}) -> last(X,Y,A);
          (X,A) -> [atom(X)|A] end,[],string:tokens(C," ,")))
    || C <- string:tokens(binary_to_list(Bin),"\n") ].

 compile(Code) ->
   {0,iolist_to_binary([ success(?MODULE,hd(I),tl(I)) || I <- Code])}.
        </code></figure>
        <p>Теперь представим как выглядит компиляция первых
           инструкций (для 32-битных и 64-битных регистров). Приводим тут только кейс
           для 64-битных регистров, но в файл аккуратно вкатываем всю доку (в предыдущей
           статье 60МБ-документ):</p>
        <figure><code>
 stur(R1,[R2,Im]) when ?x(R1), ?x(R2), ?imm(Im) ->
   Rt = reg(R1), Rn = reg(R2), I = &lt;&lt;Im:9&gt;&gt;,
   <<3:2,7:3,0:6,I/bitstring,0:2,Rn/bitstring,Rt/bitstring>>;

 mov(R1,Im) when ?x(R1), ?imm(Im) ->
   R = reg(R1), I = &lt;&lt;Im:16&gt;&gt;,
   <<1:1,2:2,37:6,0:2,I/bitstring,R/bitstring>>;

 adrp(R1,Im) when ?x(R1), ?imm(Im) ->
   Dst = reg(R1), I = &lt;&lt;(Im bsr 2):19&gt;&gt;, J = &lt;&lt;Im:2&gt;&gt;,
   <<1:1,J:2/bitstring,16:5,I:19/bitstring,Dst:5/bitstring>>.

 sub(R1,R2,Im) when ?x(R1), ?x(R2), ?imm(Im) ->
   Dst = reg(R1), Src = reg(R2), I = &lt;&lt;Im:12&gt;&gt;,
   <<1:1,1:1,0:1,34:6,0:1,I/bitstring,Src/bitstring,Dst/bitstring>>;

 add(R1,R2,Im) when ?x(R1), ?x(R2), ?imm(Im) ->
   Dst = reg(R1), Src = reg(R2), I = &lt;&lt;Im:12&gt;&gt;,
   <<1:1,0:1,0:1,34:6,0:1,I/bitstring,Src/bitstring,Dst/bitstring>>;

 stp(R1,R2,[R3,Im]) when ?x(R1), ?x(R2), ?x(R3), ?imm(Im) ->
   Dst = reg(R1), Src = reg(R2), Rn = reg(R3), I = &lt;&lt;(Im div 8):7&gt;&gt;,
   <<2:2,5:3,0:1,2:3,0:1,I/bitstring,Src/bitstring,Rn/bitstring,Dst/bitstring>>;
        </code></figure>
        <p>Любая армовская инструкция занимает ровно 3 строчки: 1) параметры и матчинг;
        2) декодирование литералов; 3) составление схемы битвектора. Я сделал так,
        что те инструкции которые пока не поддерживаются тихо фейлятся (success,
        для громкого фейла включите success_):</p>
        <figure><code>
 $ ./a64 asm.s
 $ hexdump asm
 0000000 d1 00 83 ff a9 01 7b fd 91 00 43 fd 90 00 00 08
 0000010 91 3e a1 08 52 80 00 00 b8 1f c3 a0 91 00 83 ff
        </code></figure>
        <p>— <a href="https://github.com/5HT/a64">5HT/a64</a><br></p>

    </section>
</main>
<footer>Namdak Tonpa <span class="heart">&nbsp;❤&nbsp;</span> 2009—2019</footer>
</body>
</html>

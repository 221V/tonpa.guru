<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>2019-05-08</title>
    <link rel="stylesheet" href="https://forms.n2o.space/priv/static/css/forms.css?v=1" />
    <link rel="stylesheet" href="../../blank.css?v=5" />
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>STREAM</a>
    <a href='#'>2019-05-08</a>
</nav>
<main>
    <section>
        <h3>Microsoft Terminal</h3>

        <p>Самое громкое опен соурс событие Майкрософт после первой версии WSL на BUILD.
           Майкрософт написала трушный терминал по спекам xterm с поддержкой DirectX рендерера,
           клиппинг регионами, опен соурсный Console Host, и минималистичный (86KB exe-файл) WinRT терминал с табами,
           который за 2 дня набрал 30 тыс звезд натхабе.</p>

        <p>Если вы пропустили 20 лет эволюции Microsoft API от EMM386 и Windows 16 до XAML Islands,
           самое время вспомнить про это потому, что речь о терминале. Вообще тот кто сталкивался
           с termio на UNIX вплотную, а не шапочно не мог блевать от архитектуры, но по-своему в духе
           стогкольмского синдрома лелеющий настройки терминалов termdb и прочие сказки динозавров.
           В Linux можно сказать, что референсный терминал, раотающий по спецификациям xterm.
           В Mac все тихо замалчивают проблему, и пользуются iTerm2, потому как полный набор
           CUA в Apple Terminal не работает, особонно это заметно для польлзователей Midnight Commander.
           Поэтому хотелось увидеть такой терминал от Microsoft в котором одинаково бы звучали
           шифты и контролы с курсорами так нужным нам старым динозаврам с мышечной памятью для
           навигации рептилоидным мозгом. Я работаю в iTerm2, это самый удобный пока терминал на планете,
           но после использования я захотел сделать короткий write up того что увидел в исходниках,
           возможно молодежь не знает, а деды найдут ошибки и похейтят немного!</p>

        <p>Итак, в Windows 10 существует такой фулл стек из API (Иевангелие от Максима):
           Windows NT, Win32, WinRT. Всё больше нухуя нет. Windows NT — ядро Дейва Кетлера,
           начатое еще в 1988 году, и являющееся вдохновляющем продолжением ОС Mach
           написаной в CMU (я был там!). Win32 — это 32-битное расширение 16-битного
           невытесняющегося ивинтлупа сишных стеков шарящего единое аддресное пространство (!),
           которое даже существовало для DOS/EMM386 под названием Win32s.

        <p>Win32 это публичное API которое было официальным для семейства Windows NT.
           Самая прогрессивная и взрослая система тогда была Windows NT 4.0 Hydra с
           Cytrix стеком, который сохраняет
           приемственность в RDP протоколах и сейчас.
           Это тоже Терминал, но он заслуживает отдельной статьи, там вообще космос счас,
           этот терминал умнее меня, там AI-кодеки для сжатия данных и т.д. Потом после Windows 2000
           был некоторый застой, до рассвета, когда Марк Руссинович пришел в Microsoft и порезал
           KERNEL32.DLL, USE32.DLL и GDI32.DLL на win32-api стек с помощью автоматических анализаторов кода,
           это стало начиная с Windows 7, потом был некий шаток в сторону создания всего и вся на WPF,
           но когда поняли что проблемы с латенси не пофиксать, вернулись на старый добрый COM/ActiveX
           но назвали это WinRT, и скахали что мы работаем со всеми языками. Что нового,
           VBA тоже можно было из джаваскрипта вызывать еще в 2000 году. Сейчас WinRT разделяет
           метанформация прилоежний с CLR стеком, и шарит графический язык и его редакторы типа
           Microsoft Blend, с XAML серирализацией и представляет собой просто COM/DCOM/COM+/OLE/ActiveX
           библиотеку компонент со старыми добрыми IQueryInterface и IUnknown интерфейсами,
           которые кстати были еще в CORBA. DirectX и все системне сервисы тоже использую этот способ линковки,
           там кстати существует IDL компилятор и сериализаторы можно подставлять, покруче ваших протобафов.
           Я это все рассказываю потому, что исходники Microsoft Terminal испольует весь фулстек всех трех API,
           ABI уровня ядра Windows NT, ABI C runtime и Win32 и IDL API для COM-овским компонент
           WinRT и DirectX.
           </p>
        <p>Скажу сразу информации в интернете про Windows Terminal и вообще консольный стек не много,
           почерпнуть информацию можно из имплменетации FAR и MSDN страницы по Console IO, а также
           в двух статьях из корпоративного блога:</p>
           <p>
           — <A HREF="https://devblogs.microsoft.com/commandline/introducing-windows-terminal/">Анонс Windows Terminal Кайлы Синамон</A><br>
           — <A HREF="https://devblogs.microsoft.com/commandline/windows-command-line-introducing-the-windows-pseudo-console-conpty/">Серия постов про PTY API Рича Тёрнера</A>
           </p>
           <p>Традиционно в духе Хелен Кастер приводим список всех кто делал консольный стек в Windows:</p>
         <figure> <img src="https://devblogs.microsoft.com/wp-content/uploads/sites/33/2019/02/Team-Console.png" width=600></figure>
        <p>
        </p>
        <h3>Console Host</h3>
        <p>Эта штука уже некоторое время существует как провайдер для Console API (аналог ncurses) клиентов типа FAR или putty.
           Она является главным сервером и именно в нем присутствует линковочное WinNT API для
           управления IOCTL на уровне ядра, а не на уровне Win32 (всё доходит до IRQ пакетов ядра).
           Поэтому как только команде Console API
           понадобится что-то суперважное, всегда можно подхачить Console Host как системный сервис.
           Главные компоненты консольного хоста:</p>
        <p>— Входной буфер<br>
           — Выходной буфер<br>
           — DirectX рендерер<br>
           — GDI рендерер<br>
           — VT рендерер (промежуточный, xterm, telnet)<br>
           — Имплементации специальных оконных классов (Interactivity.Win32)<br>
           — Server (фронтальное API)<br>
           — Сопряжение и ивентинг WinNT IOCTL (бекенд)</p>
        <p>Главное отличие от UNIX архитектуры в том, что вместо пайпов между
           бинарным потоком между клиентом и сервером и termio форматером,
           Windows операриует IOTCL пакетами как входящим потоком, а не
           ESC-последовательностями, поэтому терминальный Windows стек
           традиционно чуть-чуть длинее чем у UNIX-ов.</p>
        <p>Буфера и рендереры являются шаред компонентами, поэтому вы можете юзать
           в своих приложениях. Выбор между DirectX и GDI происходит в специальном
           консольном оконном классе, или другими словами, контрольном элементе
           Window.Interactivity.Win32 (там в оконной процедуре все хаки TranslateMessage).
           Протокол Server можно посмотреть в файле IoSorter.
           Протокол IRenderer или точнее последовательность рендеринга (RenderBase): цвета, скролинг,
           фон, построчная развертка, оверлеи, выделение, курсор, тайтл. IRenderEngine имеет три имплементации:
           WinTelnet, xterm, xterm256 и различные хуки для Paint. Вместе VT Interactivity и VT Renderer
           составляют то, что является PTY аналого в UNIX мире. Приложения через
           ConPTY API имеею более короткий путь до рендерера (PowerShell например),
           чем через WinNT IOCTL (как обычные ANSI приложения с интерпретацией
           ESC последовательностей).</p>

        <h3>Virtual Terminal</h3>
        <p>Это более абстрактный слой, который тоже является шаред либами.
           Тут основные компоненты следующие:</p>
        <p>— TerminalOutput<br>
           — TermnialInput (keymaps)<br>
           — MouseInput<br>
           — Terminal Parser IStateMachine</p>
        <p>Существует две имплементации стейт имашины Input и Ouput, она является средним
           знаменателем всех терминалов в мире и всех контрольных последовательностей
           разделенных на классы состояний: Ground, ESC, SCI, OSC, SS3. Terminal Input
           является элементом Termninal контрола ближе к пользователю, а Terminal Output структуры
           являются частью сервера ближе к рендерингу.</p>

        <h3>Terminal Control</h3>
        <p>Этот слой посвящен WinRT компонентам:</p>
        <p>— ITerminalConnection<br>
           — ConhostConnection<br>
           — TermControl<br>
           — Terminal<br>
           — Также IDL для KeyChord, IKeyBinding</p>
        <h3>Windows Terminal</h3>
        <p></p>
        <figure><img src="https://5ht.co/img/windows.terminal.png" width=700></figuure>
    </section>
</main>
<footer>Namdak Tonpa <span class="heart">&nbsp;❤&nbsp;</span> 2009—2019</footer>
</body>
</html>

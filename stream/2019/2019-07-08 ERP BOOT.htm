<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content=""/>
    <meta name="author" content="Namdak Tonpa"/>
    <title>2019-07-08</title>
    <link rel="stylesheet" href="../../blank.css"/>
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>TOP</a>
    <a href='#'>2019-07-08</a>
</nav>
<main>
    <section>
        <h3>Сайнерси Энтерпрайзинг<br>Часть 2. Пусконаладка Предприятия</h3>
        <p>В этой статье я расскажу как мы организовываем данные о самом предприятии
           и как мы совершаем навигаю по ним с помощью библиотеки KVS.</p>

    </section>
    <section>
        <h3>Создание корневых цепочек</h3>
        <p>ERP BOOT или пусконаладка преприятия — это процес заполнения первичных
           словарей и таблиц и всякой фундаментальной информации. Главным образом это отображение
           иерархической, организационной структуры предприятия. От работника предприятия, его рабочего места,
           его бренча, его локальной компании все
           бренчи которое находятся в одной стране, и далее до группы международных компании с офисами в разныз странах мира,
           и возможно даже до синдикатов транснациональныз корпораций. В зависимости от того какую структу вы хотите
           так вы организовываете первичные фиды.</p>

        <p>Рассмотрим пример: компания Quanterall, главный подрядчик Aethernity, имеет офисы в
           Софии, Варне (главный офис компании) и Пловдиве. Сама компания совершает операции только в Болгарии,
           поэтому группа состоит из одной компании.</p>

   <p><font face="monospace" size=4 style="white-space: pre;">
GroupOrgs    = [ #'Organization'{name="Quanterall",  url="quanterall.com"} ].
HeadBranches = [ #'Branch'{loc=#'Loc'{city="Varna",  country="BG"}},
                 #'Branch'{loc=#'Loc'{city="Sophia", country="BG"}},
                 #'Branch'{loc=#'Loc'{city="Plovdiv",country="BG"}} ].
    </font></p>

        <p>Добавляем сейчас и впредь данные с помощью обычных list комбинаторов:</p>

   <p><font face="monospace" size=4 style="white-space: pre;">
-module(erp).
-compile(export_all).
boot() ->
  case kvs:get(writer,"/erp/group") of
    {ok,_} -> skip;
    {error,_} ->
      lists:map(fun(X) -> kvs:append(X,"/erp/quanterall") end, HeadBranches),
      lists:map(fun(X) -> kvs:append(X,"/erp/group") end, GroupOrgs) end.
    </font></p>
        <p>За работу с данными отвечает библиотека KVS, как работать с ней читайте в предыдущих
           выпусках журнала:</p>
          <p>— <a href="https://tonpa.guru/stream/2019/2019-04-13%20Новая%20версия%20KVX.htm">2019-04-13 Новая Версия KVS</a><br>
          — <a href="https://github.com/synrc/kvs">synrc/kvs</a></p>
    </section>
    <section>
        <h3>Создание схемы<br>
            Генерация SDK для клиетов<br>
            Генерация валидаторов</h3>
        <p>Схемы мы храним в цепочках для каждой таблицы поэтому валиаторы
           способны траверсить и по предыдущих схемах. Схема включает в себя
           всю типовую информацию для таблиц С-структур, которые используются
           в качестве основного типа данных в качесве пейлоада для базы данных.
           Наши драйвера используют BERT кодировку. Все кто писали сложные системы
           согласились с тем, что данные в сторадже должны быть типизированны,
           это потом вы уже можете использовать словари и JSON для транспортировки,
           но валидаторы и генераторы SDK лучше писать по типовым спецификациям.
           В Erlang это выглядит так:</p>
   <p><font face="monospace" size=4 style="white-space: pre;">
-type locationType() :: normal | extra.

-record('Loc',   { id          = kvs:seq([],[]) :: [] | term(),
                   code        = [] :: [] | term(),
                   country     = [] :: [] | binary(),
                   city        = [] :: [] | binary(),
                   address     = [] :: [] | binary(),
                   type        = [] :: locationType() }).

-record('Branch',   { id     = kvs:seq([],[]) :: [] | term(),
                      loc    = [] :: [] | #'Loc'{} }).

-record('Organization', { name        = [] :: [] | binary(),
                          url         = [] :: [] | string(),
                          location    = [] :: [] | #'Loc'{},
                          type        = [] :: term() }).
    </font></p>
          <p>Другими словами в типовых спецификациях есть суммы и мы можем генерировать
             хоть Haskell спецификации, причем делать это на стадии компиляции.
             Пример набора парс трансформаций для генерации JavaScript, Swift и даже Protobuf
             спецификаций вы можете найти в этой библиотеке:</p>
          <p>— <a href="https://github.com/synrc/bert">synrc/bert</a></p>
          <p>Там же находится генератор валидаторов для самого языка Erlang.
             Почему в поставке языка отсувствует такая библиотека — тот ещё вопрос!</p>
    </section>
    <section>
        <h3>Инкапсуляция структуры предприятия</h3>
        <p>Весь код который нужен для создания фидов мы обычно выносим в приложение с названием
           ERP. Для каждого конкретного предприятия мы используем свою Github
           организацию, можно даже другое имя репозитория, но всегда это же имя Erlang/OTP
           приложления.</p>
          <p>— <a href="https://github.com/enterprizing/erp">enterprizing/erp</a></p>
        <p>В этом репозитории будут всегда какие-то реальные данные компании которую мы автоматизируем,
           если она нам разрешает публиковать свою организационную структуру, первичные данные и словари.
           Делаем этот репозиторий приватный в отдельных случаях. Сами приложения способны
           работать с любыми структурами ERP.</p>
    </section>
    <section>
        <h3>Пример</h3>
    </section>
</main>
<footer>Namdak Tonpa <span class="heart">&nbsp;❤&nbsp;</span> 2009—2019</footer>
</body>
</html>

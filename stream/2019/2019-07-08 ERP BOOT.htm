<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content=""/>
    <meta name="author" content="Namdak Tonpa"/>
    <title>2019-07-08</title>
    <link rel="stylesheet" href="../../blank.css?v=11"/>
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>TOP</a>
    <a href='#'>2019-07-08</a>
</nav>
<main>
    <section>
        <h3>Часть 2. Пусконаладка предприятия</h3>

        <p>— <a href="2019-06-30%20DEPOT.htm">Часть 1. Введение</a><br>
           — <a href="2019-07-08%20ERP%20BOOT.htm">Часть 2. Пусконаладка предприятия</a><br>
           — <a href="2019-07-08%20KVS%20ADM.htm">Часть 3. Администратор данных</a><br>
           — <a href="2019-07-09%20BPE%20ADM.htm">Часть 4. Администратор процессов</a><br>
           — <a href="2019-07-17%20ENT%20APP.htm">Часть 5. Структура приложения</a><br>
           — <a href="2019-07-19%20ENT%20PUB.htm">Часть 6. Публикация в GCP</a></p>

        <p>В этой статье я расскажу как мы организовываем данные о самом предприятии
           и как мы совершаем навигаю по ним с помощью библиотеки KVS.</p>

    </section>
    <section>

        <h3>Конфигурация</h3>

        <p>Чтобы не писать каждый раз эту прелюдию для каждого приложения приведем
           на примере PLM проекта, который уже включает почти весь стек: N2O, KVS, BPE,
           а также другие N2O протоколы CHAT, NITRO. NITRO — является портом
           Nitrogen Web Framework написанный Расти Клопхаусом.</p>

        <h4>config/config.exs</h4>
   <figure><code>
use Mix.Config

config :n2o,
  pickler: :n2o_secret,
  mq: :n2o_syn,
  port: 8043,
  proto: CHAT.Server
  mqtt_services: ['erp', 'plm'],
  ws_services: ['chat'],
  upload: "./priv/static",
  routes: <font color=red>KVS.Routes</font>,
  protocols:
  [
    :n2o_heart,
    :n2o_nitro,
    :n2o_ftp,
    :bpe_n2o,
    CHAT.TXT
  ]

config :kvs,
  dba: :kvs_rocks,
  dba_st: :kvs_st,
  schema:
  [
    :kvs,
    :kvs_stream,
    :bpe_metainfo
  ]

config :erp,
  boot:
  [
    :erp_boot,
    :acc_boot,
    :pay_boot,
    :plm_boot,
    :fin_boot
  ]
      </code></figure>

        <h3>Публикация</h3>

        <h4>mix.exs</h4>
   <figure><code>
defmodule PLM.Mixfile do
  use Mix.Project

  def project() do
    [
      app: :plm,
      version: "0.7.1",
      elixir: "~> 1.8.1",
      description: "PLM",
      deps: deps()
    ]
  end

  def application() do
    [
      mod: {PLM.Application, []},
      applications:
      [
        :ranch,
        :cowboy,
        :rocksdb,
        :kvs,
        :syn,
        :erp,
        :bpe,
        :n2o,
        :chat
      ]
    ]
  end

  def deps() do
    [
      {:ex_doc, "~> 0.20.2", only: :dev},
      {:cowboy, "~> 2.5.0"},
      {:rocksdb, "~> 1.2.0"},
      {:chat, "~> 3.7.2"},
      {:n2o, "~> 6.7.1"},
      {:syn, "~> 1.6.3"},
      {:kvs, "~> 6.7.4"},
      {:erp, "~> 0.7.6"},
      {:bpe, "~> 4.7.3"},
      {:nitro, "~> 4.7.3"}
    ]
  end
emd
    </code></figure>

        <h3>Типовые спецификации</h3>
        <p>Схемы мы храним в цепочках для каждой таблицы поэтому валиаторы
           способны траверсить и по предыдущих схемах. Схема включает в себя
           всю типовую информацию для таблиц С-структур, которые используются
           в качестве основного типа данных в качесве пейлоада для базы данных.
           Наши драйвера используют BERT кодировку. Все кто писали сложные системы
           согласились с тем, что данные в сторадже должны быть типизированны,
           это потом вы уже можете использовать словари и JSON для транспортировки,
           но валидаторы и генераторы SDK лучше писать по типовым спецификациям.
           </p>

          <p>Другими словами в типовых спецификациях есть суммы и мы можем генерировать
             хоть Haskell спецификации, причем делать это на стадии компиляции.
             Пример набора парс трансформаций для генерации JavaScript, Swift и даже Protobuf
             спецификаций вы можете найти в этой библиотеке:</p>

          <p>— <a href="https://github.com/synrc/bert">synrc/bert</a></p>

          <p>Там же находится генератор валидаторов (его конечно нужно переписать)
             для самого языка Erlang. Почему в поставке языка отсувствует такая
             библиотека — тот ещё вопрос!</p>

        <h4>ERP SPEC — Таблицы организационной структуры</h4>

   <figure><code>
-type locationType() :: normal | extra.

-record('Loc',
{ id          = kvs:seq([],[]) :: [] | term(),
  code        = [] :: [] | term(),
  country     = [] :: [] | binary(),
  city        = [] :: [] | binary(),
  address     = [] :: [] | binary(),
  type        = [] :: locationType() }).

-record('Branch',
{ id          = kvs:seq([],[]) :: [] | term(),
  loc         = [] :: [] | #'Loc'{} }).

-record('Inventory',
{ id          = [] :: [] | binary(),
  name        = [] :: [] | binary(),
  branch      = [] :: [] | #'Branch'{},
  type        = [] :: term() }).

-record('Organization',
{ name        = [] :: [] | binary(),
  url         = [] :: [] | string(),
  location    = [] :: [] | #'Loc'{},
  type        = [] :: term() }).

-record('Person',
{ id          = kvs:seq([],[]) :: [] | term(),
  cn          = [] :: [] | binary(),
  name        = [] :: [] | binary(),
  displayName = [] :: [] | binary(),
  location    = [] :: #'Loc'{},
  type        = [] :: term() }).


-record('Employee',
{ id          = kvs:seq([],[]) :: [] | binary(),
  person      = [] :: [] | #'Person'{},
  org         = [] :: [] | #'Organization'{},
  branch      = [] :: [] | #'Branch'{},
  type        = [] :: term() }).
    </code></figure>

        <h4>PAY SPEC — Таблицы системы управления платежами</h4>

        <p>Деньги хранятся в формате <b>{N,M}</b>, где <b>N</b> — количество знаков после запятой,
           а <b>M</b> — все значимые цифры. Таким образом числа кодируются множественным образом,
           например единица: 1 = {0,1} = {1,10} = {2,100}. Операция умножения зато в такой системе
           выглядит просто <b>mul({A,B},{C,D}) -> {A+C,B*D}</b>.
           </p>

   <figure><code>
-type fraction_length() :: integer().
-type digits() :: integer().
-type money() :: {fraction_length(),digits()}.

-record('Payment',
{ invoice = [] :: [] | term(),
  volume = [] :: [] | money(),
  price = {0,1} :: money(),
  instrument = [] :: term(),
  type = [] :: paymentType(),
  from = [] :: term(),
  to = [] :: term() }).
    </code></figure>

        <h4>PLM SPEC — Таблицы системы управления жизненным циклом</h4>

   <figure><code>
-record('Acc',
{ id   = [] :: [] | binary() | list(),
  rate = {0,0} :: money() }).

-record('Product',
{ code         = [] :: [] | term(),
  id           = kvs:seq([],[]) :: [] | binary(),
  url          = [] :: [] | binary() | list(),
  engineer     = [] :: [] | #'Person'{},
  director     = [] :: [] | #'Person'{},
  owner        = [] :: [] | #'Person'{},
  organization = [] :: [] | #'Organization'{},
  type         = [] :: productType() }).

-record('Investment',
{ id = [] :: [] | term(),
  volume = [] :: [] | money(),
  price = {0,1} :: money(),
  instrument = [] :: term(),
  type = [] :: investmentType(),
  from = [] :: term(),
  to = [] :: term() }).
    </code></figure>

    </section>
    <section>
        <h3>Создание корневых цепочек</h3>

        <p>ERP BOOT или пусконаладка преприятия — это процес заполнения первичных
           словарей и таблиц и всякой фундаментальной информации. Главным образом это отображение
           иерархической, организационной структуры предприятия. От работника предприятия, его рабочего места,
           его бренча, его локальной компании все
           бренчи которое находятся в одной стране, и далее до группы международных компании с офисами в разныз странах мира,
           и возможно даже до синдикатов транснациональныз корпораций. В зависимости от того какую
           организационную структуру предприятия вы хотите
           так вы раскладываете данные на первичные фиды.</p>

        <h4>ERP BOOT — Организационная структура предприятия</h4>

        <p>Рассмотрим пример: компания Quanterall, главный подрядчик Aethernity, имеет офисы в
           Софии, Варне (главный офис компании) и Пловдиве. Сама компания совершает операции только в Болгарии,
           поэтому группа состоит из одной компании.</p>

        <p>Добавляем сейчас и впредь данные с помощью обычных list комбинаторов:</p>

   <figure><code>
-module(erp).
-compile(export_all).

boot() ->
    GroupOrgs =
  [ #'Organization'{
      name="Quanterall",
      url="quanterall.com"} ],

    HeadBranches =
  [ #'Branch'{ loc = #'Loc'{ city = "Varna",
               country = "BG" } },
    #'Branch'{ loc = #'Loc'{ city = "Sophia",
               country = "BG" } },
    #'Branch'{ loc = #'Loc'{ city = "Plovdiv",
               country = "BG" } } ],

    PartnersOrgs =
  [ #'Organization'{ name="NYNJA"},
    #'Organization'{ name="Catalx"},
    #'Organization'{ name="FiaTech"},
    #'Organization'{ name="3Stars"},
    #'Organization'{ name="SwissEMX"},
    #'Organization'{ name="HistoricalPark"},
    #'Organization'{ name="Intralinks"} ],

    Structure =
  [ {"/erp/group", GroupOrgs},
    {"/erp/partners", PartnersOrgs},
    {"/erp/quanterall", HeadBranches} ],

    lists:foreach(fun({Feed, Data}) ->
       case kvs:get(writer, Feed) of
            {ok,_} -> skip;
         {error,_} -> lists:map(fun(X) ->
                      kvs:append(X,Feed)
       end, Data) end end, Structure).
    </code></figure>

        <h4>PAY BOOT — Учётность CashFlow</h4>

        <p>Управление отчетностью аутсорс предприятия достаточно простое:
           1) мы принимаем оплаты по инвойсам выставленным клиентам периодически регулярно раз в месяц;
           2) мы выплачиваем зарплаты раз в месяц. Поэтому фолды группируются календарно
           и зипуются помесячно.</p>

   <figure><code>
sal_boot() ->
   lists:map(fun(#'Product'{code=C} = P) ->
      lists:map(fun(#'Payment'{}=Pay) ->
         kvs:append(Pay,
         "/plm/"++C++"/outcome") end,
           salaries(C))
      end, products()).

pay_boot() ->
   lists:map(fun(#'Product'{code=C} = P) ->
      lists:map(fun(#'Payment'{}=Pay) ->
         kvs:append(Pay,
         "/plm/"++C++"/income") end,
           payments(C))
      end, products()).
    </code></figure>

        <h4>PLM BOOT — Бюджетирование проектов</h4>

       <p>Инициализация почасовая для каждого сотрудника по проекту.
          Этот список будет использоваться в будущем для распределения
          выплат по опционам.<b></b> </p>

   <figure><code>
assignees() ->
   lists:map(fun(#'Product'{code=C} = P) ->
      case kvs:get(writer,"/plm/"++C++"/staff") of
           {error,_} ->
             lists:map(fun(#'Person'{}=Person) ->
             kvs:append(Person,
             "/plm/"++C++"/staff") end,staff(C));
           {ok,_} -> skip end
      end, products()).
    </code></figure>


    <p>Выплаты по процентам на субконто попроектно:</p>

   <figure><code>
accounts() ->
  lists:map(fun(#'Product'{code=C}) ->
    lists:map(fun(#'Acc'{id=Id, rate=R}=SubAcc) ->
      Address = lists:concat(["/fin/acc/",C]),
      kvs:append(SubAcc,Address),
      Feed = lists:concat(["/fin/tx/",Id]),
      case kvs:get(writer, Feed) of
           {error,_} ->
             lists:map(fun(#'Payment'{
               invoice=I,price=P, volume=V}=Pay) ->
             kvs:append(rate(Pay,SubAcc,C), Feed)
             end, payments(C));
             {ok,_} -> skip
      end
    end, acc(C))
  end, plm_boot:products()).
    </code></figure>

        <p>За работу с данными отвечает библиотека KVS, как работать с ней читайте в предыдущих
           выпусках журнала:</p>
          <p>— <a href="https://tonpa.guru/stream/2019/2019-04-13%20Новая%20версия%20KVX.htm">2019-04-13 Новая Версия KVS</a><br>
          — <a href="https://github.com/synrc/kvs">synrc/kvs</a></p>
    </section>
    <section>
        <h3>Инкапсуляция структуры предприятия</h3>
        <p>Весь код который нужен для создания фидов мы обычно выносим в приложение с названием
           ERP. Для каждого конкретного предприятия мы используем свою Github
           организацию, можно даже другое имя репозитория, но всегда это же имя Erlang/OTP
           приложления.</p>
          <p>— <a href="https://github.com/enterprizing/erp">enterprizing/erp</a></p>
        <p>В этом репозитории будут всегда какие-то реальные данные компании которую мы автоматизируем,
           если она нам разрешает публиковать свою организационную структуру, первичные данные и словари.
           Делаем этот репозиторий приватный в отдельных случаях. Сами приложения способны
           работать с любыми структурами ERP.</p>
    </section>
    <section>
        <h3>Примеры запросов к хранилищу</h3>

        <p>Elixir прелюдия:</p>

   <figure><code>
defmodule PLM.Mixfile do
  use Mix.Project
  def project() do
    [
      app: :plm,
      version: "0.7.1",
      elixir: "~> 1.8.1",
      description: "PLM Product Lifecycle Management",
      deps: [{:bpe, "~> 4.7.3"}, {:erp, "~> 0.7.6"}]
    ]
  end
  def application(),
    do: [mod: {PLM.Application, []},
         applications: [:rocksdb, :kvs, :bpe, :erp]]
end
    </code></figure>

        <p>Содержимое корневой директории БД предприятия:</p>

   <figure><code>
>  :writer |> :kvs.all |> :lists.sort
[
  {:writer, '/acc/quanterall/Plovdiv', 3, [], [], []},
  {:writer, '/acc/quanterall/Sophia', 9, [], [], []},
  {:writer, '/acc/quanterall/Varna', 23, [], [], []},
  {:writer, '/bpe/hist/1562855060639704000', 1, [], [], []},
  {:writer, '/bpe/proc', 1, [], [], []},
  {:writer, '/erp/group', 1, [], [], []},
  {:writer, '/erp/partners', 7, [], [], []},
  {:writer, '/erp/quanterall', 3, [], [], []},
  {:writer, '/fin/acc/CATALX', 4, [], [], []},
  {:writer, '/fin/acc/NYNJA', 4, [], [], []},
  {:writer, '/fin/tx/CATALX/R&D', 12, [], [], []},
  {:writer, '/fin/tx/CATALX/insurance', 12, [], [], []},
  {:writer, '/fin/tx/CATALX/options', 12, [], [], []},
  {:writer, '/fin/tx/CATALX/reserved', 12, [], [], []},
  {:writer, '/fin/tx/NYNJA/R&D', 5, [], [], []},
  {:writer, '/fin/tx/NYNJA/insurance', 5, [], [], []},
  {:writer, '/fin/tx/NYNJA/options', 5, [], [], []},
  {:writer, '/fin/tx/NYNJA/reserved', 5, [], [], []},
  {:writer, '/plm/CATALX/income', 12, [], [], []},
  {:writer, '/plm/CATALX/investments', 4, [], [], []},
  {:writer, '/plm/CATALX/outcome', 12, [], [], []},
  {:writer, '/plm/CATALX/staff', 2, [], [], []},
  {:writer, '/plm/NYNJA/income', 5, [], [], []},
  {:writer, '/plm/NYNJA/investments', 2, [], [], []},
  {:writer, '/plm/NYNJA/outcome', 5, [], [], []},
  {:writer, '/plm/NYNJA/staff', 4, [], [], []},
  {:writer, '/plm/products', 2, [], [], []}
]
    </code></figure>

        <p>Список компаний входящие в группу предприяти:</p>

   <figure><code>
> :kvs.feed '/erp/group'
[{:Organization, 'Quanterall', 'quanterall.com', [], []}]
    </code></figure>

        <p>Список бреч-офисов головной (и единственной) компании группы:</p>

   <figure><code>
> :kvs.feed '/erp/quanterall'
[
  {:Branch, '1562329445378242000',
   {:Loc, '1562329445378243000', [], 'BG', 'Plovdiv', [], []}},
  {:Branch, '1562329445378241000',
   {:Loc, '1562329445378242000', [], 'BG', 'Sophia', [], []}},
  {:Branch, '1562329445378234000',
   {:Loc, '1562329445378240000', [], 'BG', 'Varna', [], []}}
]
    </code></figure>

        <p>Список контрагентнов:</p>

   <figure><code>
> :kvs.feed '/erp/partners'
[
  {:Organization, 'Catalx Exchange Inc.', 'catalx.io', [], []},
  {:Organization, 'HistoricalPark', [], [], []},
  {:Organization, 'NYNJA, Inc.', 'nynja.io', [], []},
  {:Organization, 'Intralinks', [], [], []},
  {:Organization, 'SwissEMX', [], [], []},
  {:Organization, 'FiaTech', [], [], []},
  {:Organization, '3Stars', [], [], []}
]
    </code></figure>

    <p>Бюджетирование проекта по статьям субконто:</p>

   <figure><code>
> :kvs.feed '/fin/acc/NYNJA'
[
  {:Acc, 'NYNJA/insurance', {2, 70}},
  {:Acc, 'NYNJA/reserved', {2, 10}},
  {:Acc, 'NYNJA/options', {2, 10}},
  {:Acc, 'NYNJA/R&D', {2, 10}}
]
    </code></figure>

    <p>Выплаты по опционам для программистов:</p>

   <figure><code>
> :kvs.feed '/fin/tx/CATALX/options'
[
  {:Payment, '1562868880497278000', {0, 1}, {2, 150000}, 'USD', :crypto, [], []},
  {:Payment, '1562868880496849000', {0, 1}, {2, 100000}, 'USD', :crypto, [], []},
  {:Payment, '1562868880496409000', {0, 1}, {2, 120000}, 'USD', :crypto, [], []},
  {:Payment, '1562868880495897000', {0, 1}, {2, 150000}, 'USD', :crypto, [], []},
  {:Payment, '1562868880495412000', {0, 1}, {2, 100000}, 'USD', :crypto, [], []},
  {:Payment, '1562868880494920000', {0, 1}, {2, 100000}, 'USD', :crypto, [], []},
  {:Payment, '1562868880494538000', {0, 1}, {2, 100000}, 'USD', :crypto, [], []},
  {:Payment, '1562868880494072000', {0, 1}, {2, 50000}, 'USD', :crypto, [], []},
  {:Payment, '1562868880493672000', {0, 1}, {2, 70000}, 'USD', :crypto, [], []},
  {:Payment, '1562868880493387000', {0, 1}, {2, 150000}, 'USD', :crypto, [], []},
  {:Payment, '1562868880492939000', {0, 1}, {2, 120000}, 'USD', :crypto, [], []},
  {:Payment, '1562868880492234000', {0, 1}, {2, 120000}, 'USD', :crypto, [], []}
]
    </code></figure>

    <p>Люди, работающие на проекте:</p>

   <figure><code>
> :kvs.feed '/plm/NYNJA/staff'
[
  {:Person, '1562868880467887000', 'Maxim Sokhatsky', [], [], [], 1, []},
  {:Person, '1562868880467886000', 'Yuri Maslovsky', [], [], [], 8, []},
  {:Person, '1562868880467885000', 'Nikolay Dimitrov', [], [], [], 4, []},
  {:Person, '1562868880467884000', 'Radostin Dimitrov', [], [], [], 4, []},
  {:Person, '1562868880467883000', 'Georgi Spasov', [], [], [], 8, []}
]
    </code></figure>

    </section>
    <section>
        <h3>Структура модуля предприятия</h3>

        <p>Если рассматривать первичную гранулярность предприятия, которое
           в первом приближении состоит из модулей, то уже на примере PLM
           мы можем обнаружить полную структуру типового модуля, каждый элемент
           из которой представлен в экземпляре PLM.</p>

        <h4>Конфигурация</h4>

        <p>Первый и главный компонент приложения, его файл конфигурации
           (для Erlang — <b>sys.config</b>, для Elixir — <b>consig.exs</b>)
           который нужен для множества приложений-зависимостей: <b>n2o</b>, <b>kvs</b>, <b>erp</b>, <b>form</b>.
           Это обязательный компонент любого эрланг приложения которое
           нуждается в этих зависиомостях.</p>

        <p>Более подробно про конфигурацию Erlang и Elixir приложений можно почитать тут:</p>

        <p>— <a href="https://erlang.org">Erlang</a><br>
           — <a href="https://elixir-lang.org">Elixir</a></p>

        <h4>Публикация</h4>

        <p>Для построение релиза, обычного запуска или публикации в hex.pm
           с помощью <b>mad</b>, <b>mix</b> или <b>rebar3</b>
           вам необходимо файл публикации (для Erlang — <b>rebar.config</b>,
           для Elixir — <b>mix.exs</b>). Файл публикации содержил план запуска приложений.</p>

        <p>Более подробно про публикацию Erlang и Elixir приложений можно почитать тут:</p>

        <p>— <a href="https://mad.n2o.space">mad</a> (Erlang)<br>
           — <a href="https://www.rebar3.org">rebar3</a> (Erlang)<br>
           — <a href="https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html">mix</a> (Elixir)</p>

        <h4>Типовые спецификации</h4>

        <p>Типовая спецификация — это совокупность определений типов (type),
           записей (record) и спецификаций функций (spec). Это информация для диалайзера,
           который помогает определить несоотвествие кода этим спецификациям. Все системы
           сборки поддерживают проверку dialyzer.</p>

        <p>В типовых спецификациях мы храним внутренние структуры
           фреймворков и приложений, а также бизнес-объектов предприятия.
           Язык описания бизнес объектов поддерживает кортежи (для сообщений)
           суммы (для протоколов), скалярные и векторные типы (для полей).</p>

        <p>Типовые спецификации хранятся в папке <b>include</b>, которая
           содержит HRL файлы, которые содержат типовые спецификации.
           Все -spec, -record, -type определения должны быть здесь. В Elixir
           импортируйте их с помощью <b>Record.extract</b>.</p>

        <p>Если приложение не содержит include папки (как например PLM модуль),
           то это означает, что модуль не определяет никаких дополнительных типов,
           а пользуется типами своих зависимостей либо не пользуется ими вообще.</p>

        <p>Более подробно про типовые спецификации и поддерживаемые языки программирования
           можно почитать тут:</p>

        <p>— <a href="https://bert.n2o.space">bert</a></p>

        <h4>Протоколы</h4>

        <p>Если приложение реализует какой-то протокол, это протокол встраивается
           в протокольные циклы n2o_mqtt, n2o_ws, n2o_tcp распределеннонго кольца воркеров
           которые обслуживают запросы клиентских приложений.</p>

        <p>Список протоколов определяется в переменной protocols библиотеки N2O:</p>

        <figure><code>
  protocols:
  [
    :n2o_heart,
    :n2o_nitro,
    :n2o_ftp,
    :bpe_n2o,
    CHAT.TXT
  ]
        </code></figure>

        <p>А список воркеров которые реализуют эти протоколы на эндпойнтах:</p>

        <figure><code>
  mqtt_services: ['erp', 'plm'],
  ws_services: ['chat'],
        </code></figure>

        <p>Протоколы, если они реализованы приложенинем,
           находятся в папке <b>src/protos</b> или <b>lib/protos</b>
           для Erlang и Elixir соответственно.</p>

        <p>Более подробно про N2O протоколы и их использование
           можно почитать тут:</p>

        <p>— <a href="https://ws.n2o.space">n2o</a></p>

        <h4>Цепочки</h4>

        <p>Все данные типизированные типовыми спецификациями хранятся в KVS хранилище.
           Это Erlang-ориентированная абстракция над записями/кортежами (records, tuples, C-structures) которая
           позволяется прятать за единым интерфейсом несколько KV хранилищ (включая
           Mnesia, RocksDB, Cassandra).</p>

        <p>Более подробно про систему хранениня KVS и управление типовыми спецификациями
           можно почитать тут:</p>

        <p>— <a href="https://kvs.n2o.space">kvs</a></p>

        <h4>Процессы</h4>

        <p></p>

        <p>Более подробно про систему управления бизнес-процессами BPE и ее использование
           можно почитать тут:</p>

        <p>— <a href="https://bpe.n2o.space">bpe</a></p>

        <h4>Страницы</h4>
        <h4>Редакторы</h4>
        <h4>Векторы</h4>
        <h4>Роутер</h4>

        <p>Более подробно про веб-фреймворк NITRO
           можно почитать тут:</p>

        <p>— <a href="https://nitro.n2o.space">nitro</a></p>

    </section>
</main>
<footer>Namdak Tonpa <span class="heart">&nbsp;❤&nbsp;</span> 2009—2019</footer>
</body>
</html>

<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>2019-04-13</title>
    <link rel="stylesheet" href="https://forms.n2o.space/priv/static/css/forms.css?v=1" />
    <link rel="stylesheet" href="../../blank.css?v=4" />
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>STREAM</a>
    <a href='#'>2019-04-13</a>
</nav>
<main>
    <section>
        <h3>Новая версия KVX</h3>
        <p>KVX — это слой абстракции состоящий из двух частей: базового АПИ и АПИ управления стримами,
           тейк, дроп, фолд, катаморфизм, как вы любите. Основное АПИ в модуле <b>kvx</b>,
           а стримовое в <b>kvx_stream</b>. Пользуясь случаем хочу пропиарить похожие решение
           в области хранения данных на эрланге: <a href="https://github.com/fogfish/datum">datum</a> и серия библиотек
           от Дмитрия Колесникова, или <a href="https://github.com/emqx/replayq">replayq</a> от Фенга Ли,
           а также немногих других, кто пытался абстрактно решить проблему.</p>

         <p>— <a href="https://github.com/synrc/kvx">github.com/synrc/kvx</a> — 6.4<br></p>

         <p>Начиная с легковесной модификации KVX сменила название, теперь это "Абстрактная База Цепочек",
            а не "Абстрактная База Термов", так как выделелось отдельное стрим АПИ. Поэтому сейчас мы
            опишем два подхода как модно нарезать фиды в любых KV базах. Именно второй способ
            и есть главное нововведение версии 6.4 вместе с драйвером для <b>rocksdb</b>.</p>

        <h3>Двусвязные списки</h3>
        <p>Первая идея, которая ложится прямо из С++ классов, при изучении программирование,
           это хранить в базе прямые указатели, такая система хранения может даже использоваться
           если integer поменять на pid, тогда можно будет точечно восстанавливать историю вызова.</p>

        <figure>
        <code>
  -record(iter, { id    = [] :: [] | integer(),
                  next  = [] :: [] | integer(),
                  prev  = [] :: [] | integer() } ).
        </code>
        </figure>

        <p>Первое поле любой таблицы — это ее имя, второе — id, третье и четвертое next и prev.
           Полиморфно по этим смещениям мы ожидаем наличие этих полей для линковци данных в цепочки.
           Базовая часть вместе называется #iter.</p>

        <h3>Встраивание в BTree</h3>

        <p>Существует прямой способ встраивания пространства бизнес-объектов в пространство ключей нижлежащей таблицы,
           и передача управления курсорами BTree таблицы сразу в драйвер, а не в ручной link walking как в было в riak.
           Базовая часть полиморфных рекордов состоит только из имени таблицы и id и имеет название #it.</p>

        <figure>
        <code>
  -record(it, { id = [] :: [] | integer() } ).
        </code>
        </figure>

        <p>Таким образом, мы можем эмулировать таблицы, в рамках единого пространства ключей,
           добавляя их как префиксы к ключу, который будет автоматически отражаться в основном BTree дереве,
           но также в этом пространстве вы можете хранить и фиды, т.е. стримы, например топики <b>/p2p/maxim/doxtop</b>.
           Но это требует специальной модификации kvx_st для работы с рекордом #it, в отличии от двухсвязнного
           #iter который работает с драйвером kvx_stream.</p>
        <p>Пример кода, который показывет основную идею на примере драйвера к <b>rocksdb</b>:</p>
        <p>
1> {ok,Ref} = rocksdb:open("hey",[{create_if_missing,true}]).<br>
2> rocksdb:put(Ref, <<"/users/1">>,<<"maxim">>,[{sync,true}]).<br>
3> rocksdb:put(Ref, <<"/users/2">>,<<"doxtop">>,[{sync,true}]).<br>
4> rocksdb:put(Ref, <<"/users/3">>,<<"vlad">>,[{sync,true}]).<br>
5> rocksdb:put(Ref, <<"/staff/1">>,<<"vlad">>,[{sync,true}]).<br>
6> rocksdb:put(Ref, <<"/staff/2">>,<<"maxim">>,[{sync,true}]).<br>
7> rocksdb:put(Ref, <<"/staff/3">>,<<"doxtop">>,[{sync,true}]).<br>
8> {ok,I} = rocksdb:iterator(Ref,[]).<br>
9> rocksdb:iterator_move(I,{seek,<<"/staff/">>}).<br>
10> rocksdb:iterator_move(I,next).<br>
11> rocksdb:iterator_move(I,next).<br>
12> rocksdb:iterator_move(I,next).<br>
13> rocksdb:iterator_move(I,{seek,<<"/users/">>}).<br>
14> rocksdb:iterator_move(I,next).<br>
15> rocksdb:iterator_move(I,next).<br>
16> rocksdb:iterator_move(I,next).<br>
      </p>

        <p>Теперь, что бы сделать тоже самое на KVX, вы можете сделать просто:</p>

        <p>
1> kvx:ver().<br>
2> rr(kvx).<br>
3> kvx:join().<br>
4> kvx:put(#emails{id=1,email="maxim"}).<br>
5> kvx:put(#emails{id=2,email="doxtop"}).<br>
6> kvx:put(#writer{id=2}).<br>
7> kvx:put(#writer{id=1}).<br>
8> kvx:all(writer).<br>
[#writer{id = 1,count = 0,cache = [],args = [],first = []},<br>
 #writer{id = 2,count = 0,cache = [],args = [],first = []}]<br>
9> kvx:all(emails).<br>
[#emails{id = 1,next = [],prev = [],email = "maxim"},<br>
 #emails{id = 2,next = [],prev = [],email = "doxtop"}]<br>
        </code>
        </figure>


        <p>Единственный тест на стримы, который проходит:</p>

        <p>
> kvx:check().<br>
ok
      </p>
      <p>Репозиторий, который депендит медленно-компилирующийся rocksdb NIF драйвер
         от Бенуа Кисенау (раст версию от ростовских пацанов решил отложить, слишком часто раст обновляется,
         нельзя зафризиться),
         в котором сразу включена RocksDB:</p>

         <p>— <a href="https://github.com/voxoz/kv">github.com/voxoz/kv</a><br></p>
      <p>P.S. Встраивание в BTree можно применять не только в таких базах как <b>rocksdb</b>,
         но и для <b>mnesia</b> тоже.</p>

    </section>
</main>
<footer>Namdak Tonpa <span class="heart">&nbsp;❤&nbsp;</span> 2009—2019</footer>


</body>
</html>

<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>2019-04-13</title>
    <link rel="stylesheet" href="https://forms.n2o.space/priv/static/css/forms.css?v=1" />
    <link rel="stylesheet" href="../../blank.css?v=5" />
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>STREAM</a>
    <a href='#'>2019-04-13</a>
</nav>
<main>
    <section>
        <h3>Новая версия KVX 6.4</h3>
        <p>KVX — это слой абстракции состоящий из двух частей: базового АПИ и АПИ управления стримами,
           тейк, дроп, фолд, катаморфизм, как вы любите. Основное АПИ в модуле kvx,
           а стримовое в kvx_stream. Пользуясь случаем хочу пропиарить похожие решение
           в области хранения данных на эрланге: <a href="https://github.com/fogfish/datum">datum</a> и серия библиотек
           от Дмитрия Колесникова, или <a href="https://github.com/emqx/replayq">replayq</a> от Фенга Ли,
           а также немногих других, кто пытался абстрактно решить проблему.</p>
         <p>Предназначение KVX:</p>
         <p>— абстрагирование от хранилищ;<br>
            — предоставление унифицированного интерфейса хранения на машине;<br>
            — предоставление удобного Эрланг REPL интерфейса для работы с рекордами;<br>
            — разделение на базовый (get put) и стрим интерфейс итераторов (next prev);<br>
            — базовый набор драйверов (внутренняя база, внешняя база и файловая система)</p>

         <p>Начиная с легковесной модификации KVX сменила название, теперь это "Абстрактная База Цепочек",
            а не "Абстрактная База Термов", так как выделелось отдельное стрим АПИ.</p>

         <p>— <a href="https://github.com/synrc/kvx">synrc/kvx</a> — 6.4<br></p>

        <p> Расскажем немного про теоретические основы KVX. Эта библиотека позволяет или должна
            позволять хранить и извлекать любого вида структуры предоставляя семантику управления
            курсорами next prev, которой обладают деревья. Поэтому можно сказать что это интерфейс
            оператора к цепочным и древовидным хранилищам. В своей основе KVX поддерживат три
            механизма хранения цепочек:
            1) первый способ, двусвязные списки, явный, где next и prev указатели
               непосредственным образом присутствуют в данных, подходит
               даже для управления деревьями;
            2) второй, явный, где есть только next, этот способ подходит для списков;
            3) и третий, не явный способ, где записи встраиваются в существующий индекс,
               т.е. btree таблицу, zero-overhead.</p>

        <h3>Двусвязные списки</h3>

        <p>Первая идея, которая ложится прямо из С++ классов, при изучении программирование,
           это хранить в базе прямые указатели, такая система хранения может даже использоваться
           если integer поменять на pid, тогда можно будет точечно восстанавливать историю вызова.</p>

        <figure>
        <code>
  -record(iter, { id    = [] :: [] | integer(),
                  next  = [] :: [] | integer(),
                  prev  = [] :: [] | integer() } ).
        </code>
        </figure>

        <p>Первое поле любой таблицы — это ее имя, второе — id, третье и
           четвертое next и prev (сигнатура бинарного ветвления).
           Полиморфно по этим смещениям мы ожидаем наличие этих полей
           для линковки данных в цепочки.
           Базовая часть вместе называется #iter.</p>

        <h4>kvx_stream — <b>#iter{}</b></h4>

        <p> За полиморфное явное управление application level полями next prev рекорда #iter
            отвечает модуль kvx_stream. Например файловая система не предоставляет управление
            своими кусорами, поэтому имплементация fs требует линковочных полей.</p>

        <h3>Односвязные списки</h3>
        <p>Вторая модель. Всё тоже самое, но без возврата назад.
           Не поддерживается пока ни одной версией KVX.</p>
        <figure>
        <code>
  -record(ite, { id    = [] :: [] | integer(),
                 next  = [] :: [] | integer() } ).
        </code>
        </figure>

        <h4>kvx_stre — <b>#ite{}</b></h4>

        <p>Этот модуль не имплементирован и рекорд не специфицирован.</p>

        <h3>Встраивание в индекс</h3>

        <p>Третья модель представляет собой прямой, более эффективный способ встраивания пространства бизнес-объектов
           в пространство ключей нижлежащей таблицы, и передача управления курсорами BTree таблицы
           сразу в драйвер, а не в ручной link walking как в было в riak.
           Базовая часть полиморфных рекордов состоит только из имени таблицы
           и id и имеет название #it. Эта модель используется в rocksdb бекенде, который появился в 6.4.</p>

        <figure>
        <code>
  -record(it, { id = [] :: [] | integer() } ).
        </code>
        </figure>

        <p>Таким образом, мы можем эмулировать таблицы, в рамках единого пространства ключей,
           добавляя их как префиксы к ключу (little endian), который будет автоматически
           отражаться в основном BTree дереве, но также в этом пространстве вы можете
           хранить и фиды, т.е. стримы, например топики <b>/p2p/maxim/doxtop</b>.
           Это требует специальной модификации kvx_st для работы с рекордом #it,
           в отличии от двухсвязнного #iter который работает с драйвером kvx_stream.</p>

        <h4>kvx_st — <b>#it{}</b></h4>

        <p>За управление курсорами по итератору базы данных отвечает модуль kvx_st.</p>

        <h3>На примере</h3>

        <p>Пример кода, который показывет основную идею на примере драйвера rocksdb:</p>
        <p>
1> {ok,Ref} = rocksdb:open("hey",[{create_if_missing,true}]).<br>
2> rocksdb:put(Ref, <<"/users/1">>,<<"maxim">>,[{sync,true}]).<br>
3> rocksdb:put(Ref, <<"/users/2">>,<<"doxtop">>,[{sync,true}]).<br>
4> rocksdb:put(Ref, <<"/users/3">>,<<"vlad">>,[{sync,true}]).<br>
5> rocksdb:put(Ref, <<"/staff/1">>,<<"vlad">>,[{sync,true}]).<br>
6> rocksdb:put(Ref, <<"/staff/2">>,<<"maxim">>,[{sync,true}]).<br>
7> rocksdb:put(Ref, <<"/staff/3">>,<<"doxtop">>,[{sync,true}]).<br>
8> {ok,I} = rocksdb:iterator(Ref,[]).<br>
9> rocksdb:iterator_move(I,{seek,<<"/staff/">>}).<br>
10> rocksdb:iterator_move(I,next).<br>
11> rocksdb:iterator_move(I,next).<br>
12> rocksdb:iterator_move(I,next).<br>
13> rocksdb:iterator_move(I,{seek,<<"/users/">>}).<br>
14> rocksdb:iterator_move(I,next).<br>
15> rocksdb:iterator_move(I,next).<br>
16> rocksdb:iterator_move(I,next).<br>
      </p>

      <h3>KVX REPL</h3>
        <p>Теперь, что бы сделать тоже самое на KVX, вы можете сделать просто:</p>

        <p>
1> kvx:ver().<br>
{version,"KVX ROCKSDB"}<br>
2> rr(kvx).<br>
[emails,id_seq,it,iter,kvx,reader,schema,table,writer]<br>
3> kvx:join().<br>
ok<br>
4> kvx:put(#emails{id=1,email="maxim"}).<br>
5> kvx:put(#emails{id=2,email="doxtop"}).<br>
6> kvx:put(#writer{id=2}).<br>
7> kvx:put(#writer{id=1}).<br>
8> kvx:all(writer).<br>
[#writer{id = 1,count = 0,cache = [],args = [],first = []},<br>
 #writer{id = 2,count = 0,cache = [],args = [],first = []}]<br>
9> kvx:all(emails).<br>
[#emails{id = 1,next = [],prev = [],email = "maxim"},<br>
 #emails{id = 2,next = [],prev = [],email = "doxtop"}]<br>

10> kvx:add(#writer{id=chain,args=#emails{email="maxim@synrc.com"}}).<br>
11> kvx:add(#writer{id=chain,args=#emails{email="vlad@synrc.com"}}).<br>
12> kvx:add(#writer{id=chain,args=#emails{email="doxtop@synrc.com"}}).<br>
13> kvx:all(chain).<br>
[#emails{id = 1555244691729330000,next = [],prev = [],
         email = "maxim@synrc.com"},<br>
 #emails{id = 1555244699905648000,next = [],prev = [],
         email = "doxtop@synrc.com"},<br>
 #emails{id = 1555244696660271000,next = [],prev = [],
         email = "vlad@synrc.com"}]
         </p>

        <p>Единственный тест на стримы, который проходит:</p>

        <p>
> kvx:check().<br>
ok
      </p>
      <h3>В заключение</h3>
      <p>Репозиторий (который депендит медленно-компилирующийся <a href="https://gitlab.com/barrel-db/erlang-rocksdb">rocksdb NIF драйвер</a>
         от Бенуа Кисенау, <a href="https://github.com/Vonmo/rocker">Rust-версию Rocker</a> от Максима Молчанова решил отложить,
         слишком часто раст обновляется, нельзя зафризиться).
         сразу включеет конфигурационный файл для rocksdb:</p>

         <p>— <a href="https://github.com/voxoz/kv">voxoz/kv</a><br></p>
      <p>P.S. Встраивание в BTree можно применять не только в таких базах как rocksdb,
         но и для mnesia и для любых баз вообще.</p>
      <p>P.P.S. Можно также использовать rocksdb как драйвер для мнезиии (написаный
         Ульфом Вигером для проекта Аэтернити), или скорее вид таблицы rocksdb_copies —
         <a href="https://github.com/aeternity/mnesia_rocksdb">mnesia_rocksdb</a>.</p>

    </section>
</main>
<footer>Namdak Tonpa <span class="heart">&nbsp;❤&nbsp;</span> 2009—2019</footer>


</body>
</html>
